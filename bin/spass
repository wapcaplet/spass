#!/usr/bin/env ruby

require 'spass'
require 'optparse'

HELP = <<EOF

This script generates a plain-English passphrase of at least the given length
(in characters), using random words from the given dictionary file
(/usr/share/dict/words by default). Only lowercase letters a-z will be included
in the output, making passphrases relatively easy to type (though usually
nonsensical).

Examples:

  $ spass -l 12
  hive frighten

  $ spass -l 24
  moppet castigator harvesters

A 32-character passphrase has about 120 bits of entropy, which is overkill for
most purposes. A 24-character passphrase clocks in at about 90 bits of entropy,
suitable for most high-security applications like root passwords or financial
records. You might want to use a password checker to verify the strength of
your passphrase after generating one that you like:

  http://rumkin.com/tools/password/passchk.php

Inspired by http://xkcd.com/936/

EOF

options = {
  :length => 24,
  :number => 10,
  :dict => '/usr/share/dict/words',
  :digits => false,
  :chars => 10,
}

optparse = OptionParser.new do |opts|
  opts.on('-l', '--length [NUM]', Integer,
          "Ensure passphrases are at least NUM characters.",
          "Default: #{options[:length]}") do |len|
    options[:length] = len
  end

  opts.on('-n', '--number [NUM]', Integer,
          "Generate NUM passphrases.",
          "Default: #{options[:number]}") do |num|
    options[:number] = num
  end

  opts.on('-f', '--file [FILE]', String,
          "Read words from a FILE having one word per line.",
          "Default: #{options[:dict]}") do |dict|
    options[:dict] = dict
  end

  opts.on('-d', '--digits',
          "Include random numbers from 1-99.",
          "Default: False") do |digits|
    options[:digits] = digits
  end

  opts.on('-c', '--chars NUM',
          "Limit words to NUM characters in length.",
          "Default: 10") do |chars|
    options[:chars] = chars
  end

  opts.on_tail('-h', '--help', 'Display the help page') do
    puts opts
    puts HELP
    exit 0
  end
end

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  puts optparse
  puts "*** #{e}"
  exit 1
end

sp = Generator.new(options[:dict], options)
options[:number].times do
  puts sp.generate(options[:length], :digits=>options[:digits])
end

